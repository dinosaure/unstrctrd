<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unstrctrd (unstrctrd.Unstrctrd)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">unstrctrd</a> &#x00BB; Unstrctrd</nav><h1>Module <code>Unstrctrd</code></h1><h2 id="unstrctrd."><a href="#unstrctrd." class="anchor"></a>Unstrctrd.</h2><p><b>Unstrctrd</b> (Unstructured) is a lexer/parser according RFC822. It accepts any input which respects ABNF described by RFC5322 (including obsolete form). To contextualize the purpose, email header, a part of DEB format, or HTTP 1.1 header respect, at least, a form, the <i>unstructured</i> form which allows to split a value with a <i>folding-whitespace</i> token.</p><p>This token permits to limit any values to 80 characters per line:</p><pre><code class="ml">To: Romain Calascibetta\r\n
 &lt;romain@calascibetta.org&gt;</code></pre><p>Then, others forms like email address or subject should, at least, be a subset of this form. The goal of this library is to delay complexity of this form to a little and basic library.</p><p><b>Unstrctrd</b> handles UTF-8 as well (RFC6532). Any input should always terminate by CRLF. In other case, you can use <a href="index.html#val-safely_decode"><code>safely_decode</code></a>.</p><p>An usual process with <b>Unstrctrd</b> is to use <a href="index.html#val-of_string"><code>of_string</code></a> and <i>delete</i> FWS with <a href="index.html#val-fold_fws"><code>fold_fws</code></a> like:</p><pre><code class="ml">let parse str = of_string str &gt;&gt;= fun (i, t) -&gt; Ok (fold_fws t) ;;</code></pre><p>You can <i>canonicalize</i> a string too. In other words, parse the given string, delete FWS and regenerate the string without any FWS such as:</p><pre><code class="ml"># let canon str =
    let (_, t) = safely_decode str in
    let t = replace_invalid_bytes ~f:(fun _ -&gt; None) t in
    let t = fold_fws t in
    to_utf_8_string t ;;
# canon &quot;Hello\r\n World!&quot; ;;
- : string = &quot;Hello World!&quot;</code></pre></header><dl><dt class="spec type" id="type-elt"><a href="#type-elt" class="anchor"></a><code><span class="keyword">type</span> elt</code> = <code>[ </code><table class="variant"><tr id="type-elt.Uchar" class="anchored"><td class="def constructor"><a href="#type-elt.Uchar" class="anchor"></a><code>| </code><code>`Uchar <span class="keyword">of</span> Stdlib.Uchar.t</code></td></tr><tr id="type-elt.WSP" class="anchored"><td class="def constructor"><a href="#type-elt.WSP" class="anchor"></a><code>| </code><code>`WSP <span class="keyword">of</span> <a href="index.html#type-wsp">wsp</a></code></td></tr><tr id="type-elt.LF" class="anchored"><td class="def constructor"><a href="#type-elt.LF" class="anchor"></a><code>| </code><code>`LF</code></td></tr><tr id="type-elt.CR" class="anchored"><td class="def constructor"><a href="#type-elt.CR" class="anchor"></a><code>| </code><code>`CR</code></td></tr><tr id="type-elt.FWS" class="anchored"><td class="def constructor"><a href="#type-elt.FWS" class="anchor"></a><code>| </code><code>`FWS <span class="keyword">of</span> <a href="index.html#type-wsp">wsp</a></code></td></tr><tr id="type-elt.d0" class="anchored"><td class="def constructor"><a href="#type-elt.d0" class="anchor"></a><code>| </code><code>`d0</code></td></tr><tr id="type-elt.OBS_NO_WS_CTL" class="anchored"><td class="def constructor"><a href="#type-elt.OBS_NO_WS_CTL" class="anchor"></a><code>| </code><code>`OBS_NO_WS_CTL <span class="keyword">of</span> <a href="index.html#type-obs">obs</a></code></td></tr><tr id="type-elt.Invalid_char" class="anchored"><td class="def constructor"><a href="#type-elt.Invalid_char" class="anchor"></a><code>| </code><code>`Invalid_char <span class="keyword">of</span> <a href="index.html#type-invalid_char">invalid_char</a></code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-wsp"><a href="#type-wsp" class="anchor"></a><code><span class="keyword">and</span> wsp</code><code> = <span class="keyword">private</span> string</code></dt><dt class="spec type" id="type-obs"><a href="#type-obs" class="anchor"></a><code><span class="keyword">and</span> obs</code><code> = <span class="keyword">private</span> char</code></dt><dt class="spec type" id="type-invalid_char"><a href="#type-invalid_char" class="anchor"></a><code><span class="keyword">and</span> invalid_char</code><code> = <span class="keyword">private</span> char</code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span class="keyword">private</span> <span><a href="index.html#type-elt">elt</a> list</span></code></dt><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code> = <code>[ </code><table class="variant"><tr id="type-error.Msg" class="anchored"><td class="def constructor"><a href="#type-error.Msg" class="anchor"></a><code>| </code><code>`Msg <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <span><span>(int * <a href="index.html#type-t">t</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>of_string raw</code> tries to parse <code>raw</code> and extract the <i>unstructured</i> form. <code>raw</code> should, at least, terminate by CRLF.</p></dd></dl><dl><dt class="spec value" id="val-safely_decode"><a href="#val-safely_decode" class="anchor"></a><code><span class="keyword">val</span> safely_decode : string <span>&#45;&gt;</span> int * <a href="index.html#type-t">t</a></code></dt><dd><p><code>safely_decode str</code> parses the given string and return a <a href="index.html#type-t"><code>t</code></a> and how many bytes it consumed. The process puts systematically a CRLF at the end of the given string to never fails.</p></dd></dl><dl><dt class="spec value" id="val-replace_invalid_bytes"><a href="#val-replace_invalid_bytes" class="anchor"></a><code><span class="keyword">val</span> replace_invalid_bytes : <span>f:<span>(<a href="index.html#type-invalid_char">invalid_char</a> <span>&#45;&gt;</span> <span><a href="index.html#type-elt">elt</a> option</span>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>replace_invalid_bytes f t</code> wants to replace or delete invalid bytes into the given <a href="index.html#type-t"><code>t</code></a>. You probably can replace them by <code>`Uchar Uutf.u_rep</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span><a href="index.html#type-elt">elt</a> list</span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>of_list lst</code> tries to coerce <code>lst</code> to <a href="index.html#type-t"><code>t</code></a>. It verifies that <code>lst</code> can not produce CRLF terminating token (eg. <code>[`CR; `LF]</code>).</p></dd></dl><dl><dt class="spec value" id="val-to_utf_8_string"><a href="#val-to_utf_8_string" class="anchor"></a><code><span class="keyword">val</span> to_utf_8_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_utf_8_string t</code> returns a valid UTF-8 string of <code>t</code>. The given <code>t</code> must not contain <code>`Invalid_char</code>, you probably should clean-up with <a href="index.html#val-replace_invalid_bytes"><code>replace_invalid_bytes</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>f:<span>(<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>f:<span>(<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-wsp"><a href="#val-wsp" class="anchor"></a><code><span class="keyword">val</span> wsp : <span>len:int</span> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dt class="spec value" id="val-tab"><a href="#val-tab" class="anchor"></a><code><span class="keyword">val</span> tab : <span>len:int</span> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dt class="spec value" id="val-fws"><a href="#val-fws" class="anchor"></a><code><span class="keyword">val</span> fws : <span>?&#8288;tab:bool</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dt class="spec value" id="val-without_comments"><a href="#val-without_comments" class="anchor"></a><code><span class="keyword">val</span> without_comments : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>without_comments t</code> tries to delete any comment of <code>t</code>. A comment is a part which begins with <code>'('</code> and ends with <code>')'</code>. If we find a non-associated parenthesis, we return an error.</p></dd></dl><dl><dt class="spec value" id="val-fold_fws"><a href="#val-fold_fws" class="anchor"></a><code><span class="keyword">val</span> fold_fws : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-split_at"><a href="#val-split_at" class="anchor"></a><code><span class="keyword">val</span> split_at : <span>index:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-split_on"><a href="#val-split_on" class="anchor"></a><code><span class="keyword">val</span> split_on : <span>on:<span>[ `WSP <span>| `FWS</span> <span><span>| `Uchar</span> of Stdlib.Uchar.t</span> <span><span>| `Char</span> of char</span> <span>| `LF</span> <span>| `CR</span> ]</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a>)</span> option</span></code></dt><dd><p><code>split_on ~on t</code> is either the pair <code>(t0, t1)</code> of the two (possibly empty) subparts of <code>t</code> that are delimited by the first match of <code>on</code> or <code>None</code> if <code>on</code> can't be matched in <code>t</code>.</p><p>The invariant <code>t0 ^ sep ^ t1 = t</code> holds.</p></dd></dl></div></body></html>