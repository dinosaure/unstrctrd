<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unstrctrd (unstrctrd.Unstrctrd)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">unstrctrd</a> &#x00BB; Unstrctrd</nav><header class="odoc-preamble"><h1>Module <code><span>Unstrctrd</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#unstrctrd.">Unstrctrd.</a></li></ul></nav><div class="odoc-content"><h2 id="unstrctrd."><a href="#unstrctrd." class="anchor"></a>Unstrctrd.</h2><p><b>Unstrctrd</b> (Unstructured) is a lexer/parser according RFC822. It accepts any input which respects ABNF described by RFC5322 (including obsolete form). To contextualize the purpose, email header, a part of DEB format, or HTTP 1.1 header respect, at least, a form, the <i>unstructured</i> form which allows to split a value with a <i>folding-whitespace</i> token.</p><p>This token permits to limit any values to 80 characters per line:</p><pre class="language-ocaml"><code>To: Romain Calascibetta\r\n
 &lt;romain@calascibetta.org&gt;</code></pre><p>Then, others forms like email address or subject should, at least, be a subset of this form. The goal of this library is to delay complexity of this form to a little and basic library.</p><p><b>Unstrctrd</b> handles UTF-8 as well (RFC6532). Any input should always terminate by CRLF. In other case, you can use <a href="#val-safely_decode"><code>safely_decode</code></a>.</p><p>An usual process with <b>Unstrctrd</b> is to use <a href="#val-of_string"><code>of_string</code></a> and <i>delete</i> FWS with <a href="#val-fold_fws"><code>fold_fws</code></a> like:</p><pre class="language-ocaml"><code>let parse str = of_string str &gt;&gt;= fun (i, t) -&gt; Ok (fold_fws t) ;;</code></pre><p>You can <i>canonicalize</i> a string too. In other words, parse the given string, delete FWS and regenerate the string without any FWS such as:</p><pre class="language-ocaml"><code># let canon str =
    let (_, t) = safely_decode str in
    let t = replace_invalid_bytes ~f:(fun _ -&gt; None) t in
    let t = fold_fws t in
    to_utf_8_string t ;;
# canon &quot;Hello\r\n World!&quot; ;;
- : string = &quot;Hello World!&quot;</code></pre><div class="odoc-spec"><div class="spec type anchored" id="type-elt"><a href="#type-elt" class="anchor"></a><code><span><span class="keyword">type</span> elt</span><span> = </span><span>[ </span></code><ol><li id="type-elt.Uchar" class="def variant constructor anchored"><a href="#type-elt.Uchar" class="anchor"></a><code><span>| </span><span>`Uchar <span class="keyword">of</span> <span class="xref-unresolved">Stdlib</span>.Uchar.t</span></code></li><li id="type-elt.WSP" class="def variant constructor anchored"><a href="#type-elt.WSP" class="anchor"></a><code><span>| </span><span>`WSP <span class="keyword">of</span> <a href="#type-wsp">wsp</a></span></code></li><li id="type-elt.LF" class="def variant constructor anchored"><a href="#type-elt.LF" class="anchor"></a><code><span>| </span><span>`LF</span></code></li><li id="type-elt.CR" class="def variant constructor anchored"><a href="#type-elt.CR" class="anchor"></a><code><span>| </span><span>`CR</span></code></li><li id="type-elt.FWS" class="def variant constructor anchored"><a href="#type-elt.FWS" class="anchor"></a><code><span>| </span><span>`FWS <span class="keyword">of</span> <a href="#type-wsp">wsp</a></span></code></li><li id="type-elt.d0" class="def variant constructor anchored"><a href="#type-elt.d0" class="anchor"></a><code><span>| </span><span>`d0</span></code></li><li id="type-elt.OBS_NO_WS_CTL" class="def variant constructor anchored"><a href="#type-elt.OBS_NO_WS_CTL" class="anchor"></a><code><span>| </span><span>`OBS_NO_WS_CTL <span class="keyword">of</span> <a href="#type-obs">obs</a></span></code></li><li id="type-elt.Invalid_char" class="def variant constructor anchored"><a href="#type-elt.Invalid_char" class="anchor"></a><code><span>| </span><span>`Invalid_char <span class="keyword">of</span> <a href="#type-invalid_char">invalid_char</a></span></code></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-wsp"><a href="#type-wsp" class="anchor"></a><code><span><span class="keyword">and</span> wsp</span><span> = <span class="keyword">private</span> string</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-obs"><a href="#type-obs" class="anchor"></a><code><span><span class="keyword">and</span> obs</span><span> = <span class="keyword">private</span> char</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-invalid_char"><a href="#type-invalid_char" class="anchor"></a><code><span><span class="keyword">and</span> invalid_char</span><span> = <span class="keyword">private</span> char</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span class="keyword">private</span> <span><a href="#type-elt">elt</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-error"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span><span>[ </span></code><ol><li id="type-error.Msg" class="def variant constructor anchored"><a href="#type-error.Msg" class="anchor"></a><code><span>| </span><span>`Msg <span class="keyword">of</span> string</span></code></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <a href="#type-t">t</a>, <span>[&gt; <a href="#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>of_string raw</code> tries to parse <code>raw</code> and extract the <i>unstructured</i> form. <code>raw</code> should, at least, terminate by CRLF.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-safely_decode"><a href="#val-safely_decode" class="anchor"></a><code><span><span class="keyword">val</span> safely_decode : <span>string <span class="arrow">&#45;&gt;</span></span> int * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>safely_decode str</code> parses the given string and return a <a href="#type-t"><code>t</code></a> and how many bytes it consumed. The process puts systematically a CRLF at the end of the given string to never fails.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-replace_invalid_bytes"><a href="#val-replace_invalid_bytes" class="anchor"></a><code><span><span class="keyword">val</span> replace_invalid_bytes : <span><span class="label">f</span>:<span>(<span><a href="#type-invalid_char">invalid_char</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-elt">elt</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>replace_invalid_bytes f t</code> wants to replace or delete invalid bytes into the given <a href="#type-t"><code>t</code></a>. You probably can replace them by <code>`Uchar Uutf.u_rep</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><a href="#type-elt">elt</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, <span>[&gt; <a href="#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>of_list lst</code> tries to coerce <code>lst</code> to <a href="#type-t"><code>t</code></a>. It verifies that <code>lst</code> can not produce CRLF terminating token (eg. <code>[`CR; `LF]</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_utf_8_string"><a href="#val-to_utf_8_string" class="anchor"></a><code><span><span class="keyword">val</span> to_utf_8_string : <span><span class="optlabel">?rep</span>:<span class="xref-unresolved">Stdlib</span>.Uchar.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_utf_8_string t</code> returns a valid UTF-8 string of <code>t</code>. The given <code>t</code> must not contain <code>`Invalid_char</code>, you probably should clean-up with <a href="#val-replace_invalid_bytes"><code>replace_invalid_bytes</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span class="label">f</span>:<span>(<span><a href="#type-elt">elt</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span class="label">f</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-elt">elt</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span class="label">f</span>:<span>(<span><a href="#type-elt">elt</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-elt">elt</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wsp"><a href="#val-wsp" class="anchor"></a><code><span><span class="keyword">val</span> wsp : <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-elt">elt</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tab"><a href="#val-tab" class="anchor"></a><code><span><span class="keyword">val</span> tab : <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-elt">elt</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fws"><a href="#val-fws" class="anchor"></a><code><span><span class="keyword">val</span> fws : <span><span class="optlabel">?tab</span>:bool <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-elt">elt</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-without_comments"><a href="#val-without_comments" class="anchor"></a><code><span><span class="keyword">val</span> without_comments : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, <span>[&gt; <a href="#type-error">error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>without_comments t</code> tries to delete any comment of <code>t</code>. A comment is a part which begins with <code>'('</code> and ends with <code>')'</code>. If we find a non-associated parenthesis, we return an error.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_fws"><a href="#val-fold_fws" class="anchor"></a><code><span><span class="keyword">val</span> fold_fws : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_at"><a href="#val-split_at" class="anchor"></a><code><span><span class="keyword">val</span> split_at : <span><span class="label">index</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_on"><a href="#val-split_on" class="anchor"></a><code><span><span class="keyword">val</span> split_on : 
  <span><span class="label">on</span>:<span>[ `WSP <span>| `FWS</span> <span><span>| `Uchar</span> of <span class="xref-unresolved">Stdlib</span>.Uchar.t</span> <span><span>| `Char</span> of char</span> <span>| `LF</span> <span>| `CR</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a> * <a href="#type-t">t</a>)</span> option</span></span></code></div><div class="spec-doc"><p><code>split_on ~on t</code> is either the pair <code>(t0, t1)</code> of the two (possibly empty) subparts of <code>t</code> that are delimited by the first match of <code>on</code> or <code>None</code> if <code>on</code> can't be matched in <code>t</code>.</p><p>The invariant <code>t0 ^ sep ^ t1 = t</code> holds.</p></div></div></div></body></html>
