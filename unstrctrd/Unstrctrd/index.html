<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unstrctrd (unstrctrd.Unstrctrd)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">unstrctrd</a> &#x00BB; Unstrctrd</nav><h1>Module <code>Unstrctrd</code></h1><h2 id="unstrctrd."><a href="#unstrctrd." class="anchor"></a>Unstrctrd.</h2><p><b>Unstrctrd</b> (Unstructured) is a lexer/parser according RFC822. It accepts any input which respects ABNF described by RFC5322 (including obsolete form). To contextualize the purpose, email header, a part of DEB format, or HTTP 1.1 header respect, at least, a form, the <i>unstructured</i> form which allows to split a value with a <i>folding-whitespace</i> token.</p><p>This token permits to limit any values to 80 characters per line:</p><pre><code class="ml">To: Romain Calascibetta\r\n
 &lt;romain@calascibetta.org&gt;</code></pre><p>Then, others forms like email address or subject should, at least, be a subset of this form. The goal of this library is to delay complexity of this form to a little and basic library.</p><p><b>Unstrctrd</b> handles UTF-8 as well (RFC6532). Any input should always terminate by CRLF.</p></header><dl><dt class="spec type" id="type-elt"><a href="#type-elt" class="anchor"></a><code><span class="keyword">type</span> elt</code> = <code>[ </code><table class="variant"><tr id="type-elt.Uchar" class="anchored"><td class="def constructor"><a href="#type-elt.Uchar" class="anchor"></a><code>| </code><code>`Uchar <span class="keyword">of</span> Stdlib.Uchar.t</code></td></tr><tr id="type-elt.WSP" class="anchored"><td class="def constructor"><a href="#type-elt.WSP" class="anchor"></a><code>| </code><code>`WSP <span class="keyword">of</span> <a href="index.html#type-wsp">wsp</a></code></td></tr><tr id="type-elt.LF" class="anchored"><td class="def constructor"><a href="#type-elt.LF" class="anchor"></a><code>| </code><code>`LF</code></td></tr><tr id="type-elt.CR" class="anchored"><td class="def constructor"><a href="#type-elt.CR" class="anchor"></a><code>| </code><code>`CR</code></td></tr><tr id="type-elt.FWS" class="anchored"><td class="def constructor"><a href="#type-elt.FWS" class="anchor"></a><code>| </code><code>`FWS <span class="keyword">of</span> <a href="index.html#type-wsp">wsp</a></code></td></tr><tr id="type-elt.d0" class="anchored"><td class="def constructor"><a href="#type-elt.d0" class="anchor"></a><code>| </code><code>`d0</code></td></tr><tr id="type-elt.OBS_NO_WS_CTL" class="anchored"><td class="def constructor"><a href="#type-elt.OBS_NO_WS_CTL" class="anchor"></a><code>| </code><code>`OBS_NO_WS_CTL <span class="keyword">of</span> <a href="index.html#type-obs">obs</a></code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-wsp"><a href="#type-wsp" class="anchor"></a><code><span class="keyword">and</span> wsp</code><code> = <span class="keyword">private</span> string</code></dt><dt class="spec type" id="type-obs"><a href="#type-obs" class="anchor"></a><code><span class="keyword">and</span> obs</code><code> = <span class="keyword">private</span> char</code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span class="keyword">private</span> <span><a href="index.html#type-elt">elt</a> list</span></code></dt><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code> = <code>[ </code><table class="variant"><tr id="type-error.Msg" class="anchored"><td class="def constructor"><a href="#type-error.Msg" class="anchor"></a><code>| </code><code>`Msg <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <span><span>(int * <a href="index.html#type-t">t</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>of_string raw</code> tries to parse <code>raw</code> and extract the <i>unstructured</i> form. <code>raw</code> should, at least, terminate by CRLF.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span><a href="index.html#type-elt">elt</a> list</span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>of_list lst</code> tries to coerce <code>lst</code> to <a href="index.html#type-t"><code>t</code></a>. It verifies that <code>lst</code> can not produce CRLF terminating token (eg. <code>[`CR; `LF]</code>).</p></dd></dl><dl><dt class="spec value" id="val-to_utf_8_string"><a href="#val-to_utf_8_string" class="anchor"></a><code><span class="keyword">val</span> to_utf_8_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_utf_8_string t</code> returns a valid UTF-8 string of <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>f:<span>(<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>f:<span>(<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-wsp"><a href="#val-wsp" class="anchor"></a><code><span class="keyword">val</span> wsp : <span>len:int</span> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dt class="spec value" id="val-tab"><a href="#val-tab" class="anchor"></a><code><span class="keyword">val</span> tab : <span>len:int</span> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dt class="spec value" id="val-fws"><a href="#val-fws" class="anchor"></a><code><span class="keyword">val</span> fws : <span>?&#8288;tab:bool</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dt class="spec value" id="val-without_comments"><a href="#val-without_comments" class="anchor"></a><code><span class="keyword">val</span> without_comments : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>without_comments t</code> tries to delete any comment of <code>t</code>. A comment is a part which begins with <code>'('</code> and ends with <code>')'</code>. If we find a non-associated parenthesis, we return an error.</p></dd></dl><dl><dt class="spec value" id="val-fold_fws"><a href="#val-fold_fws" class="anchor"></a><code><span class="keyword">val</span> fold_fws : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-split_at"><a href="#val-split_at" class="anchor"></a><code><span class="keyword">val</span> split_at : <span>index:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-split_on"><a href="#val-split_on" class="anchor"></a><code><span class="keyword">val</span> split_on : <span>on:<span>[ `WSP <span>| `FWS</span> <span><span>| `Uchar</span> of Stdlib.Uchar.t</span> <span><span>| `Char</span> of char</span> <span>| `LF</span> <span>| `CR</span> ]</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a>)</span> option</span></code></dt><dd><p><code>split_on ~on t</code> is either the pair <code>(t0, t1)</code> of the two (possibly empty) subparts of <code>t</code> that are delimited by the first match of <code>on</code> or <code>None</code> if <code>on</code> can't be matched in <code>t</code>.</p><p>The invariant <code>t0 ^ sep ^ t1 = t</code> holds.</p></dd></dl><aside><p>/ *</p></aside><div class="spec module-type" id="module-type-MONAD"><a href="#module-type-MONAD" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MONAD/index.html">MONAD</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-BUFFER"><a href="#module-type-BUFFER" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-BUFFER/index.html">BUFFER</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Buffer/index.html">Buffer</a> : <a href="index.html#module-type-BUFFER">BUFFER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/argument-2-Monad/index.html">Monad</a> : <a href="index.html#module-type-MONAD">MONAD</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-buffer">buffer</a> = <a href="Make/argument-1-Buffer/index.html#type-t">Buffer.t</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-lexbuf_make"><a href="#val-lexbuf_make" class="anchor"></a><code><span class="keyword">val</span> lexbuf_make : unit <span>&#45;&gt;</span> Stdlib.Lexing.lexbuf</code></dt><dt class="spec value" id="val-post_process"><a href="#val-post_process" class="anchor"></a><code><span class="keyword">val</span> post_process : <span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span>[ <span>`FWS of string</span> <span><span>| `OBS_UTEXT</span> of int * int * string</span> <span><span>| `VCHAR</span> of string</span> <span><span>| `WSP</span> of string</span> ]</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl></div></body></html>